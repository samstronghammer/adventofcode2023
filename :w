
defmodule AdventOfCode.Day14 do
  use AdventOfCode.FileUtils
  alias AdventOfCode.FileUtils

  def tick_direction(grid, {delta_row, delta_col}) do
    grid |> Enum.map(fn {{row, col}, char} = entry -> 
      next_pos = {row + delta_row, col + delta_col}
      prev_pos = {row - delta_row, col - delta_col}
      case {char, Map.get(grid, next_pos), Map.get(grid, prev_pos)} do
        {"#", _, _} -> entry 
        {".", _, "O"} -> {prev_pos, char}
        {".", _, _} -> entry
        {"O", ".", _} -> {next_pos, char}
        {"O", _, _} -> entry
      end
    end) |> Map.new
  end

  def grid_load(grid) do
    {row_max, _col_max} = FileUtils.grid_maximum(grid)
    grid |> Enum.map(fn {{row, _col}, char} -> 
      case char do
        "O" -> row_max + 1 - row
        _ -> 0
      end
    end) |> Enum.sum
  end 
  
  def rocks_load(round_rocks, max_row) do
    round_rocks |> Enum.map(fn {row, _col} -> max_row + 1 - row end) |> Enum.sum
  end

  def tilt_grid(grid, direction) do
    next_grid = tick_direction(grid, direction)
    if Map.equal?(next_grid, grid) do
      grid
    else
      tilt_grid(next_grid, direction)
    end
  end

  def find_next_pos({round_rocks, square_rocks, {delta_row, delta_col}, {max_row, max_col}} = metadata, {curr_row, curr_col}, num_rocks_seen) do
    next_pos = {curr_row + delta_row, curr_col + delta_col}
    {next_row, next_col} = next_pos
    outside_range = next_row > max_row or next_row < 0 or next_col > max_col or next_col < 0 
    case {MapSet.member?(round_rocks, next_pos), MapSet.member?(square_rocks, next_pos) or outside_range} do
      {true, true} -> raise "Impossible"
      {true, false} -> find_next_pos(metadata, next_pos, num_rocks_seen + 1)
      {false, true} -> {curr_row - delta_row * num_rocks_seen, curr_col - delta_col * num_rocks_seen}
      {false, false} -> find_next_pos(metadata, next_pos, num_rocks_seen)
    end
  end  

  def tilt_rocks_fast(round_rocks, square_rocks, delta_pos, max_pos) do
    round_rocks |> Enum.map(fn round_rock -> 
      find_next_pos({round_rocks, square_rocks, delta_pos, max_pos}, round_rock, 0)
    end)
  end
  
  def cycle_grid(grid) do
    grid |> tilt_grid({-1, 0})
         |> tilt_grid({0, -1})
         |> tilt_grid({1, 0})
         |> tilt_grid({0, 1})
  end

  def cycle_rocks(round_rocks, square_rocks, max_pos) do
    round_rocks |> tilt_rocks_fast(square_rocks, {-1, 0}, max_pos)
                |> tilt_rocks_fast(square_rocks, {0, -1}, max_pos)
                |> tilt_rocks_fast(square_rocks, {1, 0}, max_pos)
                |> tilt_rocks_fast(square_rocks, {0, 1}, max_pos)
  end

  def run() do
    grid = puzzle_lines() |> FileUtils.lines_to_grid
    round_rocks = grid |> Enum.filter(fn {_point, char} -> char === "O" end)
                       |> Enum.map(fn {point, _char} -> point end)
                       |> MapSet.new
    square_rocks = grid |> Enum.filter(fn {_point, char} -> char === "#" end)
                        |> Enum.map(fn {point, _char} -> point end)
                        |> MapSet.new
    {max_row, max_col} = FileUtils.grid_maximum(grid)
    north_round_rocks = tilt_rocks_fast(round_rocks, square_rocks, {-1, 0}, {max_row, max_col})

    #north_grid = tilt_grid(grid, {-1, 0})
    IO.inspect rocks_load(north_round_rocks, max_row)
    # needed 136 iterations to hit value cycle, length 36
    # Infinite loop logging values for me to find pattern
    final_grid = Stream.cycle(1..2) |> Stream.with_index |> Enum.reduce_while(round_rocks, fn {_, index}, round_rocks -> 
      next_grid = cycle_grid(grid)
      IO.inspect({index + 1, grid_load(next_grid)})
      {:cont, next_grid}
    end)
  end
end


